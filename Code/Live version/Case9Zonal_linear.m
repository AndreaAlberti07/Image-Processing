%This case allows the user to see how a zonal mask works using a
%discrete cosine transform DCT. The idea is to allow user to select
%two type of mask, the first one is generated by putting random
%pixels (of the DCT) to 0. The second one is generated by crossing
%out the pixel with less information, so those who are located in
%the lower right corner. For each of those two types will be generated
%more version of the mask (the number is choosen by the user), each version in more aggressives (more
%coefficient eliminated) and the results will be showed to the
%user.
 
[img_r, img_c, img_l]=size(img);
if not(img_l==1) %if image is not gray level
    msgbox('The opened image is not gray level. It will be converted into gray level.','WARNING','warn');
    img_gray=rgb2gray(img); %convert image to gray level
else
    img_gray = img;
end

block_dim=input('Insert the sub-block size you prefer (block is squared nxn) : '); %sub-block dimension for DCT
sprintf('Insert the number of masks you want to see (up to %d) : \n',block_dim); %number of different masks generated
N_masks=input('Insert the number of masks you want to see: ');

%due to how the masks are generated, the number of mask must not exceed the
%block dimension, otherwise an error will occure. So here the program check
%this fact and if it is not respected asks for another input
while N_masks > block_dim
    msgbox('Insert a valid number','Error','error');
    fprintf('Insert the number of masks you want to see (up to %d) : \n',block_dim);
    N_masks=input('Your choice : ');
end
%choose the type of mask
selected_option=2;

%with a for cycle, take an image, compute an block_dimxblock_dim block and apply to
%each sub-block the functions to generate a mask and then apply and
%display it

[img_adapted, img_r, img_c]=ImgAdapt(img_gray,block_dim); %see function file

Row_img_rec=[]; %helpfull later
Full_img_rec=[]; %helpfull later

%now that img has been modified to perfectly fit the block
%dimension choosen, we can start taking a block and apply the
%functions defined below to each subblock  

for i=1:block_dim:img_r

    for j=1:block_dim:img_c
        block=img_adapted((i:i+block_dim-1),(j:j+block_dim-1));
        
        %functions defined is thei file
        %Generatemask generates a number of masks 'N_masks' of one of the two types above and
        %outputs a multidimensional array MASK in which each level is a
        %mask, the higher the level, the more aggressive the mask. The
        %output mask_number is just a vector having as elements the number
        %of mask (1,2,3...) used to plot the errors later.
        [MASK, mask_numbers]=Generatemask(block,N_masks,selected_option);
        [block_rec,ratio]=ApplyMask(block,MASK); %see function definition

        Row_img_rec=cat(2,Row_img_rec,block_rec); %creates a multidimensional array in which each level is a different row of the image 'img' filtered and reconstructed
    end
    
    Full_img_rec=cat(1,Full_img_rec,Row_img_rec); %array multidimensionale. Ogni livello Ã¨ l'immagine originale, mascherata e ricostruita
    Eliminated_coeffs=ratio;
    Row_img_rec=[]; %azzero altrimenti ho problemi nel riniziare il ciclo j
end

ErrAndDisp(Full_img_rec,img_adapted,MASK,Eliminated_coeffs);

uiwait()

%RIASSUNTO STEPS:
% - scegli grandezza blocco e adatta immagine a quella grandezza
% replicando eventualmente le ultime n righe e/o colonne
% - estrai blocco e per ogni blocco, procedendo lunga la riga,
% genera maschere casuali/lineari, applicale e usa la trasformata
% inversa, salvando i risultati in un array 3D
%- unisci i vari array 3D prima lungo le colonne e poi lungo le
%righe per avere un array 3D finale, in cui ogni livello (in totale
%n_level=N_masks) rappresenta l'immagine mascherata e ricostruita