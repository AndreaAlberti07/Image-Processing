% Change the current folder to the folder of this m-file.
if(~isdeployed)
  cd(fileparts(which(mfilename)));
end

clear all
close all
clc

%Select an image from a preferred postion and store it into img

[name, path]=uigetfile('*.tif;*.tiff;*.jpg;*.jpeg;*.bmp;*.png','Select Image');
img=imread([path name]);
[img_r, img_c, img_l]=size(img);
fontSize=16;

selection=input('Insert the number of change you want :\n1 - Rotate \n2 - Complement \n3 - Conversion (RGB to gray / gray to RGB) \n4 - Mirror \n5 - Enhance contrast \n6 - Reduce contrast \n7 - Zonal Masking in DCT (only for gray level images) \n8 - Threshold Masking in DCT (only for grey level images) \n9 - Extract details \n10 - Denoise image \n11 - Apply a Watermark \n  - Your choice --> ');
disp('');

switch selection

    case 1
        % Rotate image by an angle choosen by the user. Display both original and
        % rotated image
        Case1Rotate

    case 2
        %Do the negative of the image inserted and display both original and
        %negative image
        Case2Complement

    case 3
        %If the image is grey, converts it to RGB working on each channel
        %If image is RGB it turns it into grey-level
        Case3Conversion

    case 4
        % Take the image and mirror it
        Case4Mirror

    case 5
        %enhance the contrast in the original image
        Case6ContrastUp    
        
    case 6
        %reduce the contrast in the image applying a logarithm on the original
        %values
        Case7ContrastDown

    case 7 % WORKS WITH BLOCKS OF DESIRED SIZE
        %This case allows the user to see how a zonal mask works using a
        %discrete cosine transform DCT. The idea is to allow user to select
        %two type of mask, the first one is generated by putting random
        %pixels (of the DCT) to 0. The second one is generated by crossing
        %out the pixel with less information, so those who are located in
        %the lower right corner. In each type of mask will be generated
        %more version of the mask, each version in more aggressives (more
        %coefficient eliminated) and the results will be showed to the
        %user.
        Case9Zonal

    case 8
        %Applies a threshold masking to the inserted image. User can choose
        %whether to use a threshold appply to sub-blocks of preferred
        %dimension, or to use other threshold technics but applied to the
        %entire images at once.
        Case10Threshold

    case 9
        %extracts details using haar 
        %if user wants all the details together
        %Indipendentely on if the image is colored or not, if the user wants
        %the 3 details together, the visualization is the same in the sense
        %that details are not classified by colors, but they are unified in the
        %same recontructed detail.

        %In the case img is colored and the users choose a particular detail,
        %is displayed not only the detail choosen relative to the entire
        %image, but also the details of the single channels R,G,B to provide
        %more information.
        %In the case user select to visualize all details together the sigle
        %channel details are not displayed
        Case11Band

    case 10
        %add and remove noise choosen by user: Gaussian (using wavelet) and
        %SP (using median filter)
        Case12Noise

    case 11
        %uses bitget to add a watermark to the image
        Case13Watermark
end

%answer=input('Do you want to save the changes? \n1 - yes \n2 - no \n');
%answer;
%if answer==1;
%   imwrite(img_mod,'Modified_image.jpg','jpg');
%end



%% -------------- FUNCTION DEFINITION ---------------

%% function [MASK , mask_numbers]=Generatemask(img,N_masks,selected_option)
        %This function takes as input: original image 'img', number of masks user
        %wants to be realized 'N_masks', the type of masks user wants 'mask_type'.
        %The type could be 1 (case 1), 2 (case 2).
        %The output is a 3D array 'MASK' in which is level is a different mask of
        %the choosen type. Mask_numbers is just a vector of sequential real number
        %that indicate the number of the mask.
   
 
%% function [img_rec]=ApplyMask(img,MASK)
        %This function takes in input an image img (1 channel) and a
        %3D array MASK which has the same size of img but multiple channel.
        %Each channel of MASK is a mask that is tranformed in logical and
        %it is applied to dct2 of img. the coefficient of dct2 which are in
        %the position of the 1 of MASK are kept, while the others,
        %corresponding to the 0 of MASK are crossed out. The output img_rec
        %is the img which has been transformed, masked and back
        %transformed. Img_rec is 3D array and is channel is the results of
        %the application of a mask (channel) of MASK.


%% function ErrAndDisp(Full_img_rec,img,MASK)   
        %This function takes in input the original image 'img' and the Full_img_rec
        %which is a 3D array, with n levels. Each level is the reconstruction of
        %the original image, masked with different technics. This function compute
        %the error between each level and the original image and plot:
        %- original image
        %- mask applied
        %- img reconstructed
        %- error
        %all for each mask (channel of the vector MASK)
        
       

%% function [img_rec, mask]=MeanThreshold(img)
        %take an image 'img' as input, and produces in output 2 different
        %thresholded images. In the img_rec1 elements > mean are crossed out, in
        %img_rec2 the opposite. All img_rec are unified in the 3D 'img_rec' array and
        %'mask' is a 3D array in which are stored the used mask.

   

%% function [img_rec, mask]=MaxHalfThreshold(img)
        %takes an image 'img' as input, and produces in output 2 different
        %thresholded images. In the img_rec1 elements > max_half are crossed out, in
        %img_rec2 the opposite. All img_rec are unified in the 3D 'img_rec' array and
        %'mask' is a 3D array in which are stored the used masks.

   

%% function [img_rec, mask]=SigmaThreshold(img)
        %take an image 'img' as input, and produces in output 2 different
        %thresholded images. In the img_rec1 elements > mean+2sigma are crossed out, in
        %img_rec2 the opposite. All img_rec are unified in the 3D img_rec array and
        %mask is a 3D array in which are stored the used masks.

   
 
%% function [img_rec, mask]=PercentageThreshold(img,PERCENTAGE)
        %takes an image 'img' as input, and produces in output 2 different
        %thresholded images. In the img_rec1 elements > PERCENTAGE*max are crossed out, in
        %img_rec2 the opposite. All img_rec are unified in the 3D img_rec array and
        %mask is a 3D array in which are stored the used masks.


%% function ContributeThreshold(img,THRESH1)
        %This thresholding method cut out all the values that give small contribute to the image
        %In particular cut out coefficients which abs(sum) represent a percentage
        %which is smaller than 1-THRESH1. The percentage is computed over the entire abs(sum) of the coefficients values.
    


%% function NumelThreshold(img,PERCENTAGE_KEPT)
        %This function takes as input the original image 'img' and a
        %PERCENTAGE_KEPT which is a percentage. The function does the dct2 of img
        %and then discard a certain number of coefficients, keeping only the
        %percentage of the total number of coefficients specified by
        %PERCENTAGE_KEPT. The coefficients are not eliminated randomly. They are
        %sorted by decreasing order and only the last x coefficients are
        %eliminated. So the idea is to eliminate the coefficients related to the
        %high frequencies and as a results the lost information regard the border
        %of the original image.
        
       

%% function ImBand(img,band_direction)
        %This function takes an image, and using wavelet transform extracts the
        %detail (band) specified by the user. 1 = horizontal details , 2 = vertical
        %details , 3 = diagonal details.

    

%% function DenoiseGaussian(img)
        %this function takes an image, applies a gaussian noise selected, then displays the results, 
        %showing using an array, the original image and the original denoised one (using different
        %technics) and the noised image and its denoised version.
    
    

%% function DenoiseSP(img)
        %this function takes an image, applies a Salt and Pepper noise selected, then displays the results 
        %showing
        % - the original image and the original denoised (so it can be used to
        % denoise an already noised image uploaded by the user)
        % - the noised image (the original with a SP noise applied) and its denoised version.
   

%% function [img_adapted, img_r, img_c]=ImgAdapt(img,block_dim)
        %This function takes in input the original image 'img, and the dimension of
        %the sub-block 'block_dim'. It adapts the image to the block dimension, by
        %adding rows or columns if necessary. The added rows are created by
        %duplicating the last n rows and same thing for the columns.
        %imgad_r and imgad_c are respectively the number of rows of the adapted
        %image and the number of columns.
        

    
  



